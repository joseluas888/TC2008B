# -*- coding: utf-8 -*-
"""M5. Revisión de avance 3_Equipo1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z_QTo8T8dwDhDMHvZekhffJ1qS__j2wg
"""

!pip install --upgrade mesa
!pip install jupyter
!pip install matplotlib

from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import json

# La clase `Model` se hace cargo de los atributos a nivel del modelo, maneja los agentes.
# Cada modelo puede contener múltiples agentes y todos ellos son instancias de la clase `Agent`.
from mesa import Agent, Model

# Debido a que necesitamos un solo agente por celda elegimos `SingleGrid` que fuerza un solo objeto por celda.
from mesa.space import SingleGrid

# Con `SimultaneousActivation` hacemos que todos los agentes se activen de manera simultanea.
from mesa.time import SimultaneousActivation

# Vamos a hacer uso de `DataCollector` para obtener el grid completo cada paso (o generación) y lo usaremos
# para graficarlo.
from mesa.datacollection import DataCollector

# mathplotlib lo usamos para graficar/visualizar como evoluciona el autómata celular.
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128
from matplotlib.colors import ListedColormap

# Definimos los siguientes paquetes para manejar valores númericos.
import numpy as np
import pandas as pd

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime
import random

#################################################################


def get_grid(model):
    grid = np.zeros((model.grid.width, model.grid.height))
    for cell in model.grid.coord_iter():
        cell_content, pos = cell
        x, y = pos
        if isinstance(cell_content, Auto):
            grid[x][y] = 2  # Valor para representar autos
        elif isinstance(cell_content, Semaforo):
            if cell_content.color == 'Verde':
                grid[x][y] = 3  # Valor para representar semáforos verdes
            elif cell_content.color == 'Rojo':
                grid[x][y] = 4  # Valor para representar semáforos rojos
            elif cell_content.color == 'Amarillo':
                grid[x][y] = 5  # Valor para representar semáforos amarillos
        elif cell_content == 1:
            grid[x][y] = 1  # Valor para representar límites de calles
    return grid



def lane_with_more_traffic(model):
    pass

class Semaforo(Agent):
    def __init__(self, unique_id, model, direccion):
        super().__init__(unique_id, model)
        self.direccion = direccion
        self.color = 'Verde' if self.direccion in ['Norte', 'Sur'] else 'Rojo'
        self.pasos = 0

    def step(self):
        if self.color == 'Verde' and self.pasos == 7:
            self.color = 'Amarillo'
            self.pasos = 0
        elif self.color == 'Amarillo' and self.pasos == 18:
            self.color = 'Rojo'
            self.pasos = 0
        elif self.color == 'Rojo' and self.pasos == 25:
            self.color = 'Verde'
            self.pasos = 0
        else:
            self.pasos += 1

class Auto(Agent):
    def __init__(self,unique_id, model):
        super().__init__(unique_id, model)
        self.waiting = False
        self.origen  = None
        self.posiciones = {
            (49,25): 'Sur', (49,26): 'Sur', (49,27): 'Sur', (49,28): 'Sur', (49,29): 'Sur', (49,30): 'Sur',
            (0,17): 'Norte', (0,18): 'Norte', (0,19): 'Norte', (0,20): 'Norte', (0,21): 'Norte', (0,22): 'Norte',
            (24,49): "Oeste",(23,49): "Oeste",(22,49): "Oeste",(21,49): "Oeste",(20,49): "Oeste",(19,49): "Oeste",
            (32,0): "Este",(31,0): "Este",(30,0): "Este",(29,0): "Este",(28,0): "Este",(27,0): "Este",
        }
        self.carriles = {
            (19,33): "Este",(20,33): "Este",(21,33): "Este",(22,33): "Este",(23,33): "Este",(24,33): "Este",
            (27,14): "Oeste",(28,14): "Oeste",(29,14): "Oeste",(30,14): "Oeste",(31,14): "Oeste",(32,14): "Oeste",
            (35,25): "Norte",(35,26): "Norte",(35,27): "Norte",(35,28): "Norte",(35,29): "Norte",(35,30): "Norte",
            (16,17): "Sur",(16,18): "Sur",(16,19): "Sur",(16,20): "Sur",(16,21): "Sur",(16,22): "Sur",
        }

    def step(self):
        # Comportamiento del agente en cada paso de tiempo
        if self.origen is None:
            self.origen = self.posiciones.get(self.pos)

        if self.pos in self.carriles:
            semaforo_asociado = [a for a in self.model.schedule.agents if isinstance(a, Semaforo) and a.direccion == self.origen][0]
            if semaforo_asociado.color == 'Rojo' or semaforo_asociado.color == 'Amarillo':
                self.waiting = True
                print("toco!")
            else:
                self.waiting = False

        if self.origen == 'Norte' and self.waiting == False:
            nueva_posicion = (self.pos[0] + 1, self.pos[1])
        elif self.origen == 'Sur' and self.waiting == False:
            nueva_posicion = (self.pos[0] - 1, self.pos[1])
        elif self.origen == 'Este' and self.waiting == False:
            nueva_posicion = (self.pos[0], self.pos[1] + 1)
        elif self.origen == 'Oeste' and self.waiting == False:
            nueva_posicion = (self.pos[0], self.pos[1] - 1)
        else:
            print("valio vrg aqui")
            nueva_posicion = self.pos
        if self.model.grid.is_cell_empty(nueva_posicion):
            self.model.grid.move_agent(self, nueva_posicion)


class Peaton(Agent):
    def __init__(self,unique_id, model):
        pass

    def step():
        pass

#################################################################

class SimulacionCruce(Model):
    def __init__(self):
        self.grid = SingleGrid(50, 50, False)
        self.schedule = SimultaneousActivation(self)
        self.current_id = 0

        # Norte - límite izquierdo
        for i in range(17):
            for j in range(15, 17):
                self.grid[i][j] = 1
        # Norte - línea de división
        for i in range(17):
            for j in range(23, 25):
                self.grid[i][j] = 1
        # Norte - límite derecho
        for i in range(17):
            for j in range(31, 33):
                self.grid[i][j] = 1
        # Oeste - límite superior
        for i in range(17, 19):
            for j in range(15):
                self.grid[i][j] = 1
        # Oeste - línea de división
        for i in range(25, 27):
            for j in range(15):
                self.grid[i][j] = 1
        # Oeste - límite inferior
        for i in range(33, 35):
            for j in range(15): #17
                self.grid[i][j] = 1
        # Este - límite superior
        for i in range(17, 19):
            for j in range(33, 50):
                self.grid[i][j] = 1
        # Este - línea de división
        for i in range(25, 27):
            for j in range(33, 50):
                self.grid[i][j] = 1
        # Este - límite inferior
        for i in range(33, 35):
            for j in range(33, 50):
                self.grid[i][j] = 1
        # Sur - límite izquierdo
        for i in range(35, 50):
            for j in range(15, 17):
                self.grid[i][j] = 1
        # Sur - línea de división
        for i in range(35, 50):
            for j in range(23, 25):
                self.grid[i][j] = 1
        # Sur - límite derecho
        for i in range(35, 50):
            for j in range(31, 33):
                self.grid[i][j] = 1


        posiciones_semaforos = {
            'Norte': (18,31),
            'Sur': (33,16),
            'Este': (18,16),
            'Oeste': (33,32)
        }

        for direccion, posicion in posiciones_semaforos.items():
                    semaforo = Semaforo(self.current_id, self, direccion)
                    self.schedule.add(semaforo)
                    self.grid.place_agent(semaforo, posicion)
                    self.current_id += 1

        # Agregar un DataCollector al modelo
        self.datacollector = DataCollector(
            model_reporters={"Grid": get_grid}
        )

    def step(self):

        # Decidir cuántos autos nuevos crear (entre 0 y 5)
        num_autos_nuevos = random.randint(0, 5)

        for _ in range(num_autos_nuevos):
            # Crear un nuevo agente Auto y agregarlo al modelo
            print("Generando ", num_autos_nuevos, " Autos")
            auto = Auto(self.current_id, self)
            self.schedule.add(auto)
            self.current_id += 1

            # Definir la posición inicial del vehículo
            #Sur: (49,25),(49,26),(49,27),(49,28),(49,29),(49,30)
            #Norte: (0,17),(0,18),(0,19),(0,20),(0,21),(0,22)
            #Este:(32,0),(31,0),(30,0),(29,0),(28,0),(27,0)
            #Oeste:(24,49),(23,49),(22,49),(21,49),(20,49),(19,49)


            initial_positions = [(49,25),(49,26),(49,27),(49,28),(49,29),(49,30),(0,17),(0,18),(0,19),(0,20),(0,21),(0,22),(32,0),(31,0),(30,0),(29,0),(28,0),(27,0),(24,49),(23,49),(22,49),(21,49),(20,49),(19,49)]
            initial_position = random.choice(initial_positions)
            while not self.grid.is_cell_empty(initial_position):
                initial_position = random.choice(initial_positions)
            self.grid.place_agent(auto, initial_position)

            print(initial_position)
            origen = auto.posiciones.get(initial_position)
            print(origen)

        # Actualizar el estado del modelo
        self.schedule.step()

        # Recopilar los datos del modelo
        self.datacollector.collect(self)

modelo = SimulacionCruce()

pasos = 55

for i in range(pasos):
    modelo.step()
    print("paso ", i, "completado")

# Obtener los datos del DataCollector del modelo
all_grid = modelo.datacollector.get_model_vars_dataframe()

# Crear una figura y un eje para la animación
fig, ax = plt.subplots()

# Función para actualizar la imagen en cada cuadro de la animación
def update(i):
    ax.clear()
    ax.set_xticks([])
    ax.set_yticks([])
    cmap = ListedColormap(["white", "black", "purple", "green", "red"])
    ax.imshow(all_grid.iloc[i][0], cmap=cmap)

# Crear la animación
ani = animation.FuncAnimation(fig, update, frames=range(pasos), interval=200)

# Mostrar la animación
plt.show()

ani